#    Copyright 2013 Cloudscaling Group, Inc
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

import webob

from gceapi import exception
from gceapi.api import utils
from gceapi import wsgi_ext as openstack_wsgi
from gceapi.openstack.common import log as logging
from gceapi.openstack.common import jsonutils

LOG = logging.getLogger(__name__)


class JSONDictSerializer(openstack_wsgi.DictSerializer):
    """JSON request body serialization."""

    def serialize(self, data, request):
        params = {'false': False, 'true': True}
        pretty_print = request.params.get("prettyPrint", True)
        if pretty_print in params:
            pretty_print = params[pretty_print]
        ident = None
        if pretty_print:
            ident = 4
        ret = jsonutils.dumps(data,
                default=jsonutils.to_primitive, indent=ident)
        return ret


class GCEResponse(openstack_wsgi.ResponseObject):
    """GCE Response body serialization."""

    def serialize(self, request, content_type, default_serializers=None):
        if self.serializer:
            serializer = self.serializer
        else:
            _mtype, _serializer = self.get_serializer(content_type,
                                                      default_serializers)
            serializer = _serializer()

        response = webob.Response()
        response.status_int = self.code
        for hdr, value in self._headers.items():
            response.headers[hdr] = value
        response.headers['Content-Type'] = content_type
        if self.obj is not None:
            response.body = serializer.serialize(self.obj, request)

        return response


class GCEFault(webob.exc.HTTPException):
    """Wrap webob.exc.HTTPException to provide API friendly response."""

    def __init__(self, exception):
        """Create a Fault for the given webob.exc.exception or nova.exception.
        """
        self.wrapped_exc = exception
        for key, value in self.wrapped_exc.headers.items():
            self.wrapped_exc.headers[key] = str(value)


class GCEResourceExceptionHandler(object):
    """Context manager to handle Resource exceptions.

    Used when processing exceptions generated by API implementation
    methods (or their extensions).  Converts most exceptions to Fault
    exceptions, with the appropriate logging.
    """

    def __enter__(self):
        return None

    def __exit__(self, ex_type, ex_value, ex_traceback):
        if not ex_value:
            return True

        if isinstance(ex_value, exception.NotAuthorized):
            msg = unicode(ex_value)
            raise GCEFault(webob.exc.HTTPForbidden(explanation=msg))
        elif isinstance(ex_value, exception.Invalid):
            msg = unicode(ex_value)
            raise GCEFault(exception.ConvertedException(
                    code=ex_value.code, explanation=msg))

        # Under python 2.6, TypeError's exception value is actually a string,
        # so test # here via ex_type instead:
        # http://bugs.python.org/issue7853
        elif issubclass(ex_type, TypeError):
            exc_info = (ex_type, ex_value, ex_traceback)
            LOG.error(_('Exception handling resource: %s') % ex_value,
                    exc_info=exc_info)
            raise GCEFault(webob.exc.HTTPBadRequest())
        elif isinstance(ex_value, GCEFault):
            LOG.info(_("Fault thrown: %s"), unicode(ex_value))
            raise ex_value
        elif isinstance(ex_value, webob.exc.HTTPException):
            LOG.info(_("HTTP exception thrown: %s"), unicode(ex_value))
            raise GCEFault(ex_value)
        elif isinstance(ex_value, exception.NovaException):
            LOG.info(_("Nova exception thrown: %s"), unicode(ex_value))
            raise GCEFault(ex_value)

        # We didn't handle the exception
        return False


class GCEResource(openstack_wsgi.Resource):
    """Common GCE resource response formatter"""

    def __init__(self, *args, **kwargs):
        super(GCEResource, self).__init__(*args, **kwargs)
        self.default_serializers = dict(json=JSONDictSerializer)

    def _format_error(self, ex_value):
        msg = ''
        code = 200
        if isinstance(ex_value, exception.NotAuthorized):
            msg = _('Unauthorized')
            code = 401
        elif isinstance(ex_value, webob.exc.HTTPException):
            msg = ex_value.explanation
            code = ex_value.code
        elif isinstance(ex_value, exception.NovaException):
            msg = ex_value.args[0]
            code = ex_value.code
        else:
            msg = _('Internal server error')
            code = 500

        return {
            'error': {'errors': [{'message': msg}]},
            'code': code,
            'message': msg
            }, code

    def _check_requested_project(self, project_id, context):
        if (not context or project_id is None
        or (project_id not in [context.project_id, context.project_name])):
            msg = _("Project '%s' could not be found" % project_id) \
                if project_id is not None \
                else _("Project hasn`t been provided")

            raise GCEFault(webob.exc.HTTPBadRequest(
                explanation=msg))

    def _process_stack(self, request, action, action_args,
                       content_type, body, accept):
        """Implement the processing stack."""
        method = None
        post = []
        return_code = 200
        try:
            # Get the implementing method
            try:
                method, extensions = self.get_method(request, action,
                                                   content_type, body)
            except (AttributeError, TypeError):
                msg = _("There is no such action: %s") % action
                raise GCEFault(webob.exc.HTTPNotFound(
                    explanation=msg))
            except KeyError as ex:
                msg = _("There is no such action: %s") % ex.args[0]
                raise GCEFault(webob.exc.HTTPBadRequest(
                    explanation=msg))
            except exception.MalformedRequestBody:
                msg = _("Malformed request body")
                raise GCEFault(webob.exc.HTTPBadRequest(
                    explanation=msg))

            # Now, deserialize the request body...
            try:
                if content_type:
                    contents = self.deserialize(method, content_type, body)
                else:
                    contents = {}
            except exception.InvalidContentType:
                msg = _("Unsupported Content-Type")
                raise GCEFault(webob.exc.HTTPBadRequest(
                    explanation=msg))
            except exception.MalformedRequestBody:
                msg = _("Malformed request body")
                raise GCEFault(webob.exc.HTTPBadRequest(
                    explanation=msg))

            # Update the action args
            action_args.update(contents)

            project_id = action_args.pop("project_id", None)
            context = request.environ.get('nova.context')

            action_result = self._check_requested_project(project_id, context)

            # Run pre-processing extensions
            response, post = self.pre_process_extensions(extensions,
                                                         request, action_args)

            if not response and action_result is None:
                with GCEResourceExceptionHandler():
                    action_result = self.dispatch(method, request, action_args)

            # format output if 'fields' provided
            try:
                action_result = \
                    self._format_output(request, action, action_result)
            except ValueError:
                msg = _("Invalid field selection %s")\
                    % (request.params.get('fields', None))
                raise GCEFault(webob.exc.HTTPBadRequest(
                    explanation=msg))
        except GCEFault as ex:
            # format error into action_result
            action_result, return_code = self._format_error(ex.wrapped_exc)

        resp_obj = None
        if type(action_result) is dict or action_result is None:
            resp_obj = GCEResponse(action_result, code=return_code)
        elif isinstance(action_result, GCEResponse):
            resp_obj = action_result
        else:
            response = action_result

        # Run post-processing extensions
        if resp_obj:
            openstack_wsgi._set_request_id_header(request, resp_obj)
            # Do a preserialize to set up the response object
            if method is not None:
                serializers = getattr(method, 'wsgi_serializers', {})
            else:
                serializers = {}
            resp_obj._bind_method_serializers(serializers)
            if method is not None and hasattr(method, 'wsgi_code'):
                resp_obj._default_code = method.wsgi_code
            resp_obj.preserialize(accept, self.default_serializers)
            # Process post-processing extensions
            response = self.post_process_extensions(post, resp_obj,
                                                    request, action_args)
        if resp_obj and not response:
            response = resp_obj.serialize(request, accept,
                                          self.default_serializers)

        try:
            msg_dict = dict(url=request.url, status=response.status_int)
            msg = _("%(url)s returned with HTTP %(status)d") % msg_dict
        except AttributeError, e:
            msg_dict = dict(url=request.url, e=e)
            msg = _("%(url)s returned a fault: %(e)s") % msg_dict

        LOG.info(msg)
        return response

    def _format_output(self, request, action, action_result):
        fields = request.params.get('fields', None)
        if action not in ('index', 'show') or fields is None:
            return action_result

        if action == 'show':
            action_result = utils.apply_template(fields, action_result)
            return action_result
        sp = utils.split_by_comma(fields)
        top_level = []
        items = []
        for string in sp:
            if 'items' in string:
                items.append(string)
            else:
                top_level.append(string)
        res = {}
        if len(items) > 0:
            res['items'] = []
        for string in top_level:
            dct = utils.apply_template(string, action_result)
            for key, val in dct.items():
                res[key] = val
        for string in items:
            if '(' in string:
                dct = utils.apply_template(string, action_result)
                for key, val in dct.items():
                    res[key] = val
            elif string.startswith('items/'):
                string = string[len('items/'):]
                for element in action_result['items']:
                    dct = utils.apply_template(string, element)
                    res['items'].append(dct)

        return res
